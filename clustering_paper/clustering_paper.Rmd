---
title: A clustering algorithm to organize satellite hotspots data for the purpose of tracking bushfires remotely
author:
  - name: Weihao Li
    affiliation: Monash University
    address:
    - line 1
    - line 2
    email:  wlii0039@student.monash.edu
  - name: Emily Dodwell
    affiliation: AT&T
    address:
    - line 1
    - line 2
    email:  emdodwell@gmail.com
  - name: Dianne Cook
    affiliation: Monash University
    address:
    - line 1
    - line 2
    email:  dicook@monash.edu
abstract: >
  An abstract of less than 150 words.
preamble: |
  \newtheorem{defn}{Definition}
  \usepackage{flafter}
output: rticles::rjournal_article
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE, 
  cache=FALSE, 
  message=FALSE, 
  warning=FALSE, 
  fig.retina = 3, 
  out.width="80%")
```

```{r libraries}
library(tidyverse)
library(ggthemes)
library(sf)
library(ggpubr)
library(rnaturalearth)
library(lubridate)
library(gridExtra)
```

```{r Run-Algorithm, include = FALSE}
if (any(!file.exists(c("data/VIC_hotspots_before_clustering.csv", 
                       "data/VIC_hotspots_raw.csv")))){
  system("Rscript scripts/Clustering-Python-setup.R")
} 

if (!file.exists("data/clustering_grid.csv")){
  system("python scripts/clustering_tune.py")
} 

if (any(!file.exists(c("figures/clustering_tuning_1.jpeg", 
                       "figures/clustering_tuning_2.jpeg")))){
  system("Rscript scripts/clustering_tune_vis.R")
}

if (!file.exists("data/VIC_hotspots_after_clustering.csv")){
  system("python scripts/main.py")
}

if (!file.exists("figures/fire_mov.jpeg")){
  system("Rscript scripts/FireMov.R")
}
```


## Introduction

Bushfires are a major problem for Australia, and many other parts of the globe. There is concern that as the climate becomes hotter, and drier, that the impact of fires becomes much more severe and extensive. In Australia, the 2019-2020 fires were the worst on record causing extensive ecological damage, as well as damage to agricultural resources, properties and infrastructure. The Wollemi pine, rare prehistoric trees, required special forces intervention to prevent the last stands in the world, in remote wilderness areas, from being turned into ash. 

Contributing to the problem is that many fires started in very remote areas, locations deep into the temperate forests ignited by lightning, that are virtually impossible to access or to monitor. Satellite data provides a possible solution to this, particularly remotely sensed hotspot data, which may be useful in detecting new ignitions and movements of fires. Understanding fires in remote areas using satellite data may provide some help in developing effective strategies for mitigating bushfire impact. 

This work addresses this topic. Using hotspot data, can we cluster in space and time, in order to determine (1) points of ignition and (2) track the movement of bushfires. 

This paper is organised as follows. The next section provides an introduction to the literature on spatiotemporal clustering and bushfire modeling and dynamics. Section [Algorithm] describes the clustering algorithm, and section [Application] illustrates how the resulting data can be used to study bushfire ignition. 

<!--
- What is the data, generic structure
- Lit review: Spatio-temporal clustering. Algorithms for tracking movement.
- Bushfire literature review?
-->

## Background

literature review 


## Algorithm 

### Data source

This algorithm is initially developed in the research of 2019-2020 bushfires in Victoria, Australia. Therefore, the illustration of this algorithm will use hotspot data during 2019-2020 Australian bushfire season taken from Himawari-8 satellite [@jaxa]. This satellite hotpot dataset contains records of 1989572 hotspots for 6 months in the full disk of 140 \textdegree east longitude.

The data pre-processing procedure includes selecting hotspots within the boundary of Victoria and filtering hotspots with a threshold (irradiance over 100 watts per square metre) suggested by @hotspots  to reduce noise from the background. 

The final dataset contains 75936 hotspots with ID, longitude, latitude and observed date as fields. The map of this dataset is shown in Figure \ref{fig:hotspots}.

 

```{r}
au_map <- ne_states(country = 'Australia', returnclass = 'sf')
vic_map <- au_map[7,]
hotspots <- read_csv("data/VIC_hotspots_raw.csv")
memberships <- read_csv("data/VIC_hotspots_after_clustering.csv")
hotspots$fire_id <- memberships$fire_id
rm(memberships)
```

```{r hotspots, fig.cap="A map shows the distribution of hotspots in Victoria during 2019-2020 Australia bushfire season."}
if (!file.exists("figures/before_clustering.png")){
  ggplot() +
  geom_sf(data = vic_map) +
  geom_point(data = hotspots, aes(lon, lat), alpha = 0.3) +
  theme_map() -> p

  ggsave(filename = "figures/before_clustering.png", dpi = 600, plot = p)
}


knitr::include_graphics("figures/before_clustering.png")
```

### Steps

The spatiotemporal clustering algorithm is consist of 4 steps, (1) divide hotspots into intervals, (2) cluster hotspots spatially, (3) update the membership labels and (4) compute ignition locations. They will be described in details in the rest of the section. 


**1. Divide hotspots into intervals**

A characteristic of the hotspot data is cloud cover could lead to missing observations of a bushfire in several hours. This suggests that the algorithm needs to link hotspots with long intervals. Moreover, one of the difficulties to perform clustering on spatiotemporal data is to determine the scaling of the temporal dimension since the clustering results could be highly sensitive to the scaling [@kisilevich2009spatio]. One possible solution to this issue is dividing hotspot data into short intervals. In other words, the temporal dependence between hotspots is predetermined by introducing a parameter $ActiveTime$. The interpretation of $ActiveTime$ is the time a fire can stay smouldering but undetectable by satellite before flaring up again. 

Given a certain value of $ActiveTime$ and the length of the time frame $T$, the algorithm would define several intervals,

$$\boldsymbol{S}_t = [max(1,t-ActiveTime),t],~~t = 1,2,...,T$$

For example, if the dataset contains 48 hours of hotspots and the $ACtiveTime = 24~hours$, there will be 48 segments $\boldsymbol{S}_1,\boldsymbol{S}_2,..,\boldsymbol{S}_{48}$, where

\begin{align*}
\boldsymbol{S}_1 &= [1,1]\\
\boldsymbol{S}_2 &= [1,2]\\
&...\\
\boldsymbol{S}_{25} &= [1,25]\\
\boldsymbol{S}_{26} &= [2,26]\\
&...\\
\boldsymbol{S}_{47} &= [23,47]\\
\boldsymbol{S}_{48} &= [24,48]
\end{align*}

**2. Cluster hotspots in each segment individually**

Since the algorithm broke the temporal dimension in **step 1**, the local clustering for each segment only needed to address the hotspots spatially by introducing the second parameters $AdjDist$. $AdjDist$ represented the potential potential distance a fire could spread with respect to the temporal resolution of the data. For example, let $AdjDist = 3000 m$ and the temporal resolution of the data is 10-minute, then the potential speed of the bushfire is $3000m/10~min = 18km/h$. 

Given a certain value of $AdjDist$ and the segment $\boldsymbol{S}_t$, the algorithm would 

(a) Append a randomly selected hotspot $h_i$ to a empty list $\boldsymbol{L}$, where $h_i$ is the $i$th hotspot in the segment $\boldsymbol{S}_t$, and let pointer $\boldsymbol{P}$ points to the first element of the list $\boldsymbol{L}$.

(b) Visit every $h_i$ where $h_i \notin \boldsymbol{L}$. If $geodesic(h_i, \boldsymbol{P})\leq AdjDist$, appends $h_i$ to list $\boldsymbol{L}$.

(c) Move pointer $\boldsymbol{P}$ to the next element of the list $\boldsymbol{L}$.

(d) Repeat (b) and (c) till the pointer $\boldsymbol{P}$ reaches to the end of the list $\boldsymbol{L}$.

(e) For hotspots $h_i \in \boldsymbol{L}$, assign a new membership to them. Repeat (a) to (d) for unassigned hotspots in segment $\boldsymbol{S}_t$.

**3. Updated the clustering results recursively**






### Effects of parameter choices

There are two parameters that can be tuned in this algorithm. They are `adj_dist`, which is the density distance and `active_time`, which is the .



## Application

### Determining the ignition point and time for individual fires

<center> <em> Show ignition points for a particularly heavy day and another for a particularly light day </em> </center>

```{r}
hotspots %>%
  group_by(fire_id) %>%
  summarise(hour_id = min(hour_id)) %>%
  ungroup() -> temp

ignition <- left_join(temp, hotspots) %>%
  group_by(fire_id) %>%
  summarise(time = mean(`#obstime`), lon = mean(lon), lat = mean(lat))

ggplot(ignition) +
  geom_sf(data = vic_map) +
  geom_point(aes(lon, lat))
  
```

```{r}
ignition <- mutate(ignition, year = year(time), month = month(time), day = day(time))
```

```{r}
# light
filter(ignition, year == 2020, month == 1, day == 24) %>%
ggplot() +
  geom_sf(data = vic_map) +
  geom_point(aes(lon, lat)) +
  ggtitle("2020.01.24")
```
```{r}
# heavy
filter(ignition, year == 2019, month == 12, day == 18) %>%
ggplot() +
  geom_sf(data = vic_map) +
  geom_point(aes(lon, lat)) +
  ggtitle("2019.12.18")
```


### Tracking fire movement

<center> <em> Display showing how a fire moves over time, maybe two or more fires </em> </center>


### Allocating resources for future fire prevention

Merging data with camp sites, CFA, roads, ... 

## Summary


<!--
This file is only a basic article template. For full details of _The R Journal_ style and information on how to prepare your article for submission, see the [Instructions for Authors](https://journal.r-project.org/share/author-guide.pdf).
-->

## Acknowledgements

- The code and files to reproduce this work are at XXX
- Data on hotspots can be downloaded from XXX


\bibliography{RJreferences}
